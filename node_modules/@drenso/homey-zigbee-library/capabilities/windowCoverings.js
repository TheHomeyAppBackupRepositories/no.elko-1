"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const zigbee_clusters_1 = require("zigbee-clusters");
const valueRange_1 = __importDefault(require("../lib/helper/valueRange"));
const attributeDevice_1 = require("../lib/attributeDevice");
const UP_OPEN = 'upOpen';
const DOWN_CLOSE = 'downClose';
const LIFT_PERCENTAGE = 'currentPositionLiftPercentage';
const SET_CAPABILITY = 'windowcoverings_set';
const STATE_CAPABILITY = 'windowcoverings_state';
const SET_TILT_CAPABILITY = 'windowcoverings_tilt_set';
const CLUSTER_SPEC = zigbee_clusters_1.CLUSTER.WINDOW_COVERING;
const REPORT_DEBOUNCE_TIME = 5000;
const STATE_COMMAND_MAP = {
    up: 'upOpen',
    idle: 'stop',
    down: 'downClose',
};
async function initWindowCoveringsDevice(device, zclNode, { endpointId, } = {}) {
    if (!device.hasCapability(SET_CAPABILITY)) {
        return;
    }
    device.log(`Initialising ${SET_CAPABILITY} capability`);
    const parsePercentageValue = function (value) {
        // Validate input
        if (value < 0x00 || value > 0x64)
            return null;
        // Parse input value
        return (0, valueRange_1.default)(0, 100, 0, 1, value);
    };
    const endpoint = endpointId ?? device.getClusterEndpoint(CLUSTER_SPEC) ?? 1;
    const cluster = zclNode
        .endpoints[endpoint]
        .clusters[CLUSTER_SPEC.NAME];
    const setParser = async function (value) {
        device.debug(`Newly set value for ${SET_CAPABILITY}`, value);
        // Refresh timer or set new timer to prevent reports from updating the dim slider directly
        // when set command from Homey
        if (device.positionPercentageDebounce) {
            device.positionPercentageDebounce.refresh();
        }
        else {
            device.positionPercentageDebounce = device.homey.setTimeout(() => {
                device.positionPercentageDebounceEnabled = false;
                device.positionPercentageDebounce = null;
            }, REPORT_DEBOUNCE_TIME);
        }
        // Used to check if reports are generated based on set command from Homey
        device.positionPercentageDebounceEnabled = true;
        // Override goToLiftPercentage to enforce blind to open/close completely
        if (value === 0 || value === 1) {
            const windowCoveringCommand = value === 1 ? UP_OPEN : DOWN_CLOSE;
            device.debug(`set → \`windowcoverings_set\`: ${value} → setParser → ${windowCoveringCommand}`);
            await cluster[windowCoveringCommand]();
            await device.setCapabilityValue('windowcoverings_set', value);
            return null;
        }
        const mappedValue = (0, valueRange_1.default)(0, 1, 0, 100, value);
        const gotToLiftPercentageCommand = {
            // Round, otherwise might not be accepted by device
            percentageLiftValue: Math.round(mappedValue),
        };
        device.debug(`set → \`${SET_CAPABILITY}\`: ${value} → setParser → goToLiftPercentage`, gotToLiftPercentageCommand);
        // Send command
        return gotToLiftPercentageCommand;
    };
    const reportParser = function (value) {
        // Value comes from uint8
        device.debug(`Newly reported value for ${SET_CAPABILITY}`, value);
        const parsedValue = parsePercentageValue(value);
        if (parsedValue === null)
            device.error('Lift percentage value outside valid range');
        // Refresh timer if needed
        if (device.positionPercentageDebounce) {
            device.positionPercentageDebounce.refresh();
        }
        // If reports are not generated by set command from Homey update directly
        if (!device.positionPercentageDebounceEnabled) {
            return parsedValue;
        }
        // Return default
        return null;
    };
    // Retrieve initial values
    await (0, attributeDevice_1.readInitialValue)(device, zclNode, SET_CAPABILITY, CLUSTER_SPEC, LIFT_PERCENTAGE, reportParser, endpoint);
    // Configure the capability
    device.registerCapability(SET_CAPABILITY, CLUSTER_SPEC, {
        endpoint,
        getOpts: {
            getOnStart: false,
        },
        get: 'currentPositionLiftPercentage',
        set: 'goToLiftPercentage',
        setParser,
        report: 'currentPositionLiftPercentage',
        reportParser,
    });
    device.log(`Initialised ${SET_CAPABILITY} capability`);
    // Check for state support, if so
    if (device.hasCapability(STATE_CAPABILITY)) {
        device.log(`Initialising ${STATE_CAPABILITY} capability`);
        device.registerCapability(STATE_CAPABILITY, CLUSTER_SPEC, {
            endpoint,
            set: (value) => STATE_COMMAND_MAP[value],
            setParser: () => ({}),
        });
        device.log(`Initialised ${STATE_CAPABILITY} capability`);
    }
    // Check for tilt support, if so
    if (device.hasCapability(SET_TILT_CAPABILITY)) {
        device.log(`Initialising ${SET_TILT_CAPABILITY} capability`);
        device.registerCapability(SET_TILT_CAPABILITY, CLUSTER_SPEC, {
            endpoint,
            getOpts: {
                getOnStart: false,
            },
            get: 'currentPositionTiltPercentage',
            set: 'goToTiltPercentage',
            setParser: value => ({
                percentageTiltValue: value * 100,
            }),
            report: 'currentPositionTiltPercentage',
            reportParser: (value) => {
                // Value comes from uint8
                device.debug(`Newly reported value for ${SET_TILT_CAPABILITY}`, value);
                const percentageValue = parsePercentageValue(value);
                if (percentageValue === null)
                    device.error('Tilt percentage value outside valid range');
                return percentageValue;
            },
        });
        device.log(`Initialised ${SET_TILT_CAPABILITY} capability`);
    }
}
exports.default = initWindowCoveringsDevice;
